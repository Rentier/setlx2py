// Die Prozedur eval(f, i) wertet die aussagen-logische Formel f unter
// der aussagen-logischen Interpretation i aus.
evaluate := procedure(f, i) {
    match (f) {
        case true:         return true;
        case false:        return false;
        case ^variable(p): return i[p];
        case !g:           return !evaluate(g, i);
        case g && h:       return  evaluate(g, i) && evaluate(h, i);
        case g || h:       return  evaluate(g, i) || evaluate(h, i);
        case g => h:       return  evaluate(g, i) => evaluate(h, i);
        case g <==> h:     return  evaluate(g, i) == evaluate(h, i);
        default:           abort("syntax error in evaluate($f$, $i$)");
    }
};

// This procedure turns a subset m of the set of all variables 
// into a propositional valuation i, such that i(x) is true 
// iff x is an element of m.
createValuation := procedure(m, v) {
    return { [ x, x in m ] : x in v };
};

// Wenn Herr Meier kommt, bringt er auch Frau Meier mit.
f1 := parse("hm => fm");
// Mindestens eines der beiden Kinder Walter und Katrin wird kommen.
f2 := parse("w || k");
// Entweder kommt Frau Meier oder Franziska, aber nicht beide.
f3 := parse("(fm || f) && !(fm && f)");
// Entweder kommen Fransizka und Katrin zusammen oder beide kommen nicht.
f4 := parse("f <==> k");
// Wenn Walter kommt, dann kommen auch Katrin und Herr Meier.
f5 := parse("w => k && hm");

fs := {f1, f2, f3, f4, f5};
v  := {"hm", "fm", "w", "k", "f"};
p  := 2 ** v;
b  := { createValuation(m, v) : m in p };
s  := { i : i in b | forall (f in fs | evaluate(f, i)) };
print("Set of all valuations satisfying all facts: ", s);
if (#s == 1) {
    i := arb(s);
    besucher := { x : x in v | i[x] };
    print("Es kommen ", besucher, " zu Besuch");
}



