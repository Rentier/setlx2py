// Drei Missionare und drei Kannibalen wollen zusammen einen FluÃ 
// Ã¼berqueren. Das Boot hat nur Platz fÃ¼r zwei Passagiere.  Die Kannibalen
// sind hungrig, wenn die Missionare an einem Ufer in der Unterzahl sind, 
// haben sie ein Problem.  Die Aufgabe besteht darin, einen Fahrplan zu 
// erstellen, so dass hinterher alle am anderen Ufer ankommen und die
// Missionare nicht gefressen werden.

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Die folgenden Prozeduren dienen nur dem Ausdrucken der LÃ¶sung und    //
// zum Debuggen.
//                                                                      //
//////////////////////////////////////////////////////////////////////////    

// Dieses PrÃ¤dikat druckt die LÃ¶sung aus.
printPath := procedure(path) {
    print("LÃ¶sung:\n");
    for (i in [1 .. #path - 1]) {
        [ m1, k1, b1 ] := path[i];
        [ m2, k2, b2 ] := path[i+1];
        printState(m1, k1, b1);
        printBoat(m1, k1, b1, m2, k2, b2);
    }
    [ m, k, b ] := path[#path];
    printState(m, k, b);
};


// Die Prozedur printState(m, k, b) druckt den Zustand, bei dem
// m Missionare, k Kannibalen und b Boote am linken Ufer sind.
printState := procedure(m, k, b) {
     print( fillCharsRight(m * "M", 6) + 
            fillCharsRight(k * "K", 6) + 
            fillCharsRight(b * "B", 3) + "    |~~~~~|    " + 
            fillCharsLeft((3 - m) * "M", 6) + 
            fillCharsLeft((3 - k) * "K", 6) + 
            fillCharsLeft((1 - b) * "B", 3) 
          );
};

// Die Prozedur printBoat(m1, k1, b1, m2, k2, b2) druckt den Zustand des
// Bootes, wenn der Zustand sich von [m1, k1, b1] zu [m2, k2, b2] Ã¤ndert.
printBoat := procedure(m1, k1, b1, m2, k2, b2) {
    if (b1 == 1) {
        if (m1 < m2) {
            print("Fehler in printBoat: negative Anzahl von Missionaren im Boot!");
        }
        if (k1 < k2) {
            print("Fehler in printBoat: negative Anzahl von Kannibalen im Boot!");
        }
        print( 19 * " " + "> " + fillCharsBoth( (m1 - m2) * "M" + " " + (k1 - k2) * "K", 3 ) + " >" );
    } else {
        if (m1 > m2) {
            print("Fehler in printBoat: negative Anzahl von Missionaren im Boot!");
        }
        if (k1 > k2) {
            print("Fehler in printBoat: negative Anzahl von Kannibalen im Boot!");
        }
        print( 19 * " " + "< " + fillCharsBoth( (m2 - m1) * "M" + " " + (k2 - k1) * "K", 3 ) + " <" );
    }
};

// Die Prozedur fillCharsLeft(x, n) wandelt x in einen String der LÃ¤nge n um.
// Dabei wird der String von links mit Leerzeichen aufgefÃ¼llt.
fillCharsLeft := procedure(x, n) {
    s := x + "";
    m := n - #s;
    return m * " " + s;
};

// Die Prozedur fillCharsRight(x, n) wandelt x in einen String der LÃ¤nge n um.
// Dabei wird der String von rechts mit Leerzeichen aufgefÃ¼llt.
fillCharsRight := procedure(x, n) {
    s := x + "";
    m := n - #s;
    return s + m * " ";
};

// Die Prozedur fillCharsBoth(x, n) wandelt x in einen String der LÃ¤nge n um.
// Dabei wird der String von links und rechts mit Leerzeichen aufgefÃ¼llt.
fillCharsBoth := procedure(x, n) {
    s  := x + "";
    ml := (n     - #s) \ 2;
    mr := (n + 1 - #s) \ 2;
    return ml * " " + s + mr * " ";
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Die unten aufgefÃ¼hrten Prozeduren sind 1-zu-1 aus dem Programm zur   //
// LÃ¶sung des Wolf-Ziege-Kohl-Problems kopiert.                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// Check wether there is a path from x to y in R and compute it.
findPath := procedure(x, y, r) {
    p := { [x] };
    while (true) {
        oldP  := p;
        p     := p + pathProduct(p, r);
        found := { l : l in p | l[#l] == y };
        if (found != {}) {
            return arb(found);
        }
        if (p == oldP) {
            return;
        }
    }
};

// The procedure call product(p, q) computes the path product p * q.
pathProduct := procedure(p, q) {
    return { add(x,y) : x in p, y in q | x[#x] == y[1] && !cyclic(add(x,y)) };
};

// The procedure not_cyclic(p) checks whether the path p is cyclic.
cyclic := procedure(p) {
    return #{ x : x in p } < #p;
};

// The product call add(p,q) computes the sum of the lists p and q.
// The last point of p has to be the first point of q.
add := procedure(p, q) {
    return p + q[2..];
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Ab hier beginnt der Code zur LÃ¶sung des Problems.                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// Es gibt ein Problem, wenn es an einem Ufer weniger Missionare als 
// Kannbialen sind, es sei denn, dass an dem Ufer Ã¼berhaupt keine 
// Missionare sind.
problem := procedure(m, k) {
    return m > 0 && m < k;
};
// Die einzelnen Punkte werden durch Tripel beschrieben.  Das Tripel
// [ m, k, b ] gibt an, dass m Missionare, k Kannibalen und b Boote am
// linken Ufer sind. Die Zahl der Missionare am rechten Ufer ist damit
// automatisch 3 - m, die Zahl der Kannibalen am rechten Ufer ist 3 - k
// und die Zahl der Boote am rechten Ufer ist 1 - b.

// P beschreibt alle mÃ¶glichen ZustÃ¤nde.
p := { [ m, k, b ] : m in {0..3}, k in {0..3}, b in {0,1} 
                   | !problem(m, k) && !problem(3-m, 3-k)
     };
print("#p  = $#p$");
// r1 beschreibt ZustandsÃ¼bergÃ¤nge, bei denen das Boot vom linken Ufer
// zum rechten Ufer fÃ¤hrt. pm ist die Anzahl der Missionare, die im Boot
// Ã¼bersetzen und pk ist die Anzahl der Kannibalen im Boot.
r1 := { [ [ m, k, 1 ], [ m - pm, k - pk, 0 ] ] 
      : [ m, k, b ] in p, pm in {0..m}, pk in {0..k} 
      | pm + pk in {1,2} && [m - pm, k - pk, 0] in p         
      };  
print("#r1 = $#r1$");
// r2 beschreibt ZustandsÃ¼bergÃ¤nge, bei denen das Boot vom rechten Ufer
// zum linken Ufer fÃ¤hrt. Die Relation r2 ist die zu r1 inverse Relation.
r2 := { [b, a] : [a, b] in r1 };
// r ist die Menge aller Verbindungen zwischen Punkten.
r := r1 + r2;
// Am Anfang sind alle links.
start := [3,3,1];
// Am Ende sollen alle rechts sein, links ist dann niemand mehr.
goal  := [0,0,0];
// Berechne alle mÃ¶glichen Pfade.
path  := findPath(start, goal, r);
// und geben diesen Schritt fÃ¼r Schritt aus.
if (path != om) {
    printPath(path);
} else {
    print("No solution found!");
}



