////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Die folgenden Prozeduren dienen dem Ausdrucken und dem Berechnen eines     //
// Pfades.                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// Druckt den Pfad aus
printPath := procedure(list, all) {
    for (i in [1 .. #list]) {
        left  := list[i][1];
        right := all - left;
        print(left, " " * 70, right);
        if (i < #list) {
            if (list[i][2] == 1) {
                print(" " * 40, ">>> ", list[i][1] - list[i+1][1], " >>>");
            } else {
                print(" " * 40, "<<< ", list[i+1][1] - list[i][1], " <<<");
            }
        }
    }
};
    
// Compute all points reachable from start in less then limit steps.
reachable := procedure(start, r, limit) {
    pathSet := { [ [start], 0 ] }; // start is reachable from start with a path of length 0
    for (i in { 1 .. limit }) {
        pathSet += pathProduct(pathSet, r);
    }
    return pathSet;
};

// The procedure call pathProduct(p, q) computes the path product p * q.
pathProduct := procedure(p, q) {
    return { [ add(x, y), l1 + l2 ] : [ x, l1 ] in p, [ y, l2 ] in q 
                                    | x[#x] == y[1]      &&
                                      !cyclic(add(x, y)) 
           };
}; 

// The procedure cyclic(p) checks whether the path p is cyclic.
cyclic := procedure(p) {
    return #{ x : x in p } < #p;
};

// The product call add(p,q) computes the sum of the lists p and q.
// The last point of p has to be the first point of q.
add := procedure(p, q) {
    return p + q[2..];
};    

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Ab hier m